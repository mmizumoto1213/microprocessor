# GET HIGHEST POTENTIAL VALUE
IMM 11111111
# SET MIN VALUE HIGH FOR FUTURE COMPARISON
MOV R7

--- BEGINNING OF OUTER LOOP ---
# LOAD JUMP TO END OF THE SCRIPT IN CASE INNER LOOP IS FINISHED (133 lines down)
IMM 00000000
# MOVE THAT LOCATION TO R14
MOV R14
# LOAD THE VALUE THAT IS ASSOCIATED TO THE END OF THE LOOP
IMM 01000000
# IF EQUAL JUMP TO THE OUTER LOOP
BEQ R9
# RESET R0
IMM 00000000
# ADD INDEX OF FIRST HALFWORD
ADD R1
# MOVE INDEX TO R15 TO PREPARE ACCESSING IT
MOV R15
# MOVE INDEX TO R9 FOR STORING FOR FURTHER USE
MOV R9
# GET FIRST HALFWORD FROM MEMORY
LW R0
# MOVE IT TO CORRECT REGISTER
MOV R1
# ADD 1 TO GET INDEX OF SECOND HALFWORD
IMM 00000001
# ADD INDEX OF FIRST HALFWORD TO 1
ADD R9
# MOVE INDEX TO R15 TO PREPARE ACCESSING IT
MOV R15
# GET IMMEDIATE 1 TO PREPARE INDEX FOR NEXT LOOP
IMM 00000001
# ADD BACK THE CURRENT INDEX
ADD R15
# MOVE INDEX TO R9 FOR STORING FOR FURTHER USE
MOV R9
# GET SECOND HALFWORD FROM MEMORY
LW R0
# ADD IT TO CORRECT INDEX
MOV R2
# RESET 0 TO PREPARE FOR INDEX
IMM 00000000
# GET INDEX OF LAST HALFWORD
ADD R9
# MOVE INDEX TO BE THE START OF THE INNER LOOP
MOV R10

--- BEGINNING OF INNER LOOP ---
# LOAD JUMP TO OUTER JUMP IN CASE INNER LOOP IS FINISHED (24 lines up)
IMM 00000001
# MOVE THAT LOCATION TO R14
MOV R14
# LOAD THE VALUE THAT IS ASSOCIATED TO THE END OF THE LOOP
IMM 01000000
# IF EQUAL JUMP TO THE OUTER LOOP
BEQ R10
# SET R0 TO THE END OF THE HALFWORDS CHECK IF WE REACHED END OF LOOP
IMM 00000000
# RESET HAMMING DISTANCE TOTAL
IMM 00000000
# MOVE HAMMING DISTANCE TOTAL RESET
MOV R6
# PREP R0 FOR NEXT HALFWORD
IMM 00000001
# GET LAST INDEX OF HALFWORDS
ADD R10
# MOVE INDEX TO R15 TO PREPARE ACCESSING IT
MOV R15
# MOVE INDEX TO R10 FOR STORING FOR FURTHER USE
MOV R10
# GET FIRST HALFWORD FROM MEMORY
LW R0
# MOVE IT TO CORRECT REGISTER
MOV R3
# RESET R0 AND PREP IT FOR NEXT HALFWORD
IMM 00000001
# ADD INDEX OF PREVIOUS HALFWORD
ADD R10
# MOVE INDEX TO R15 TO PREPARE ACCESSING IT
MOV R15
# LOAD IMMEDIATE 1 TO GET THE NEXT INDEX USED FOR THE NEXT LOOP
IMM 00000001
# ADD THE CURRENT INDEX BACK
ADD R15
# MOVE INDEX TO R10 FOR STORING FOR FURTHER USE
MOV R10
# GET SECOND HALFWORD FROM MEMORY
LW R0
# ADD IT TO CORRECT INDEX
MOV R4
# RESET R0 TO PREPARE IT FOR XOR
IMM 00000000
# MOVE FIRST HALFWORD INTO R0 FOR XOR USAGE
ADD R1
# XOR BOTH FIRST HALFWORDS
XOR R3
# STORE XOR VALUE TO CORRESPONDING REGISTER
MOV R5
# STORE XOR VALUE THAT CAN BE MODIFIED FOR COUNTING LOOP
MOV R11
# RESET R0 TO PREPARE IT FOR SECOND XOR
IMM 00000000
# MOVE SECOND HALFWORD INTO R0 FOR XOR USAGE
MOV R2
# XOR BOTH SECOND HALFWORDS
XOR R4
# STORE XOR VALUE TO CORRESPONDING REGISTER
MOV R5
# STORE XOR VALUE TO MODIFIABLE STORAGE
MOV R13
# GET IMMEDIATE 0 FOR RESETTING COUNTING LOOP
IMM 00000000
# SET COUNTING LOOP ITERATOR TO 0
MOV R12
# IMMEDIATE THE DISTANCE TO THE START OF THE COUNTING LOOP (15 lines down)
IMM 00000010
# LOAD R14 WITH START OF COUNTING LOOP
MOV R14
# SET R0 TO THE END OF THE COUNTING LOOP TO BE ABLE TO JUMP
IMM 00001000
# JUMP TO THE COUNTING LOOP
BLT R12
# RESET R0 TO BE READY TO ADD MAX VALUE
IMM 00000000
# ADD THE CURRENT MAX VALUE
ADD R8
# IMMEDIATE THE DISTANCE TO THE START OF THE MAX CHANGE (56 lines down)
IMM 00000011
# LOAD R14 WITH START OF MAX CHANGE
MOV R14
# COMPARE CURRENT MAX AND CURRENT HAMMING DISTANCE
BGT R6
# RESET R0 TO BE READY TO ADD MIN VALUE
IMM 00000000
# ADD THE CURRENT MIN VALUE
ADD R7
# IMMEDIATE THE DISTANCE TO THE START OF THE MIN CHANGE (60 lines down)
IMM 00000100
# LOAD R14 WITH START OF MIN CHANGE
MOV R14
# COMPARE CURRENT MIN AND CURRENT HAMMING DISTANCE
BLT R6
# SET R0 BACK TO 0 TO GET READY FOR INNER LOOP CHECKS
IMM 00111111
# IMMEDIATE THE DISTANCE TO THE START OF THE INNER LOOP
IMM 00000101
# LOAD R14 WITH START OF INNER LOOP
MOV R14
# IF CURRENT INNER LOOP INDEX IS LESS THAN 63 JUMP TO START OF INNER LOOP
BLT R10

--- BEGINNING OF COUNTING 1S LOOP ---
# RESET R0
IMM 00000000
# ADD XOR RESULT THAT IS MODIFIED
ADD R11
# BARREL SHIFT RIGHT ONCE TO GET THE LEAST SIGNIFICANT BIT
SBR R0
# MOVE THE MODIFIED XOR VALUE TO MODIFIED STORAGE PLACE
MOV R11
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 1
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 2
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 3
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 4
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 5
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 6
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 7
SHR R0
# ADD HAMMING DISTANCE TOTAL FOR THE NUMBER
ADD R6
# MOVE TOTAL BACK TO CORRECT
MOV R6
# LOAD IMMEDIATE 1 TO ITERATE LOOP
IMM 000000001
# ADD CURRENT ITERATOR VALUE TO R0
ADD R12
# MOVE ITERATOR TO CORRECT REGISTER
MOV R12
# LOAD IMMEDIATE TO THE START OF COUNTING LOOP (19 lines up)
IMM 00000110
# MOVE IT TO THE CORRECT REGISTER
MOV R14
# LOAD IMMEDIATE 8 AS THAT WILL BE THE END OF THE LOOP
IM 00001000
# IF LESS THAN 8 JUMP BACK TO THE START OF THE COUNTING LOOP
BLT R12
# OTHER WISE GET READY FOR THE SECOND HALFWORD BY RESETTING THE INDEX
IMM 00000000
# MOVE THE RESET INDEX TO R12
MOV R12

--- BEGINNING OF COUNTING 1S LOOP PART 2 ---
# RESET R0
IMM 00000000
# ADD XOR RESULT THAT IS MODIFIED
ADD R13
# BARREL SHIFT RIGHT ONCE TO GET THE LEAST SIGNIFICANT BIT
SBR R0
# MOVE THE MODIFIED XOR VALUE TO MODIFIED STORAGE PLACE
MOV R13
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 1
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 2
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 3
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 4
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 5
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 6
SHR R0
# LOGICAL SHIFT RIGHT TO ELIMINATE OBSOLETE BITS 7
SHR R0
# ADD HAMMING DISTANCE TOTAL FOR THE NUMBER
ADD R6
# MOVE TOTAL BACK TO CORRECT
MOV R6
# LOAD IMMEDIATE 1 TO ITERATE LOOP
IMM 000000001
# ADD CURRENT ITERATOR VALUE TO R0
ADD R12
# MOVE ITERATOR TO CORRECT REGISTER
MOV R12
# IMMEDIATE THE DISTANCE TO THE MIDDLE OF THE INNER LOOP WHERE WE JUMPED FROM (55 Lines Up)
IMM 00000111
# LOAD R14 WITH MIDDLE OF INNER LOOP
MOV R14
# LOAD IMMEDIATE 8 AS THAT WILL BE THE END OF THE LOOP
IM 00001000
# IF EQUAL TO OR GREATER THAN 8 JUMP TO INNER LOOP
BGE R12
# IMMEDIATE THE DISTANCE TO THE START OF THE THIS COUNTING LOOP (22 Lines Up)
IMM 00001000
# LOAD R14 WITH START OF COUNTING LOOP
MOV R14
# BRANCH BACK TO THE START OF THE COUNTING LOOP
BEQ R0

--- CHANGE MAX ---
# LOAD IN THE CORRECT MEMORY LOCATION
IMM 01000001
# MOVE MEMORY LOCATION TO R15 TO BE ABLE TO USE IT
MOV R15
# RESET R0 IN ORDER TO BE ABLE TO ADD TO IT
IMM 00000000
# ADD IN HAMMING DISTANCE
ADD R6
# CHANGE THE CURRENT MAX PLACEHOLDER
MOV R8
# STORE THE HIGHEST HAMMING DISTANCE INTO MEMORY
SW R0
# IMMEDIATE THE DISTANCE TO THE START OF THE INNER LOOP (105 Lines Up)
IMM 00001001
# LOAD R14 WITH START OF INNER LOOP 
MOV R14
# BRANCH BACK TO THE INNTER LOOP
BEQ R0


--- CHANGE LOWEST ---
# LOAD IN THE CORRECT MEMORY LOCATION
IMM 01000000
# MOVE MEMORY LOCATION TO R15 TO BE ABLE TO USE IT
MOV R15
# RESET R0 IN ORDER TO BE ABLE TO ADD TO IT
IMM 00000000
# ADD IN HAMMING DISTANCE
ADD R6
# CHANGE THE CURRENT LOWEST PLACEHOLDER
MOV R7
# STORE THE LOWEST HAMMING DISTANCE INTO MEMORY
SW R0
# IMMEDIATE THE DISTANCE TO THE START OF THE INNER LOOP (114 Lines Up)
IMM 00001010
# LOAD R14 WITH START OF INNER LOOP 
MOV R14
# BRANCH BACK TO THE INNTER LOOP
BEQ R0
